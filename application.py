from flask import Flask, render_template, request, redirect, url_for, flash, jsonify
from dotenv import load_dotenv
from langchain_openai import ChatOpenAI
from langchain.prompts import PromptTemplate
from flask_sqlalchemy import SQLAlchemy
import difflib
import openai
from io import BytesIO 
import os
from models.election_state import ElectionState

app = Flask(__name__)
app.secret_key = 'your_secret_key'

# Load environment variables from the .env file for security and flexibility
def load_env_vars():
    """
    Load and validate environment variables.
    """
    load_dotenv()
    api_key = os.getenv("OPENAI_API_KEY")
    db_uri = os.getenv("DATABASE_URL")

    if not api_key:
        raise ValueError("API key not found. Ensure OPENAI_API_KEY is set in your environment.")

    return api_key, db_uri

# Load environment variables
api_key, db_uri = load_env_vars()
# Initialize OpenAI client with API key
client = openai.OpenAI(api_key=api_key)

# Initialize the GPT-4 model via LangChain for generating restaurant candidates
model = ChatOpenAI(model="gpt-4", api_key=api_key)

election_state = ElectionState()

# LangChain prompt template for generating restaurant candidates based on user input
restaurant_prompt_template = PromptTemplate(
    input_variables=["number_of_restaurants", "city", "state"],
    template=(
        "Generate {number_of_restaurants} interesting restaurant options in {city}, {state}."
        " List each restaurant name on a new line.\n\n"
        "Example output:\n"
        "- The Blue Moon Restaurant\n"
        "- The Red Sun Restaurant\n"
        "- The Green Earth Restaurant\n"
        "- The Yellow Star Restaurant\n"
        "- The Purple Planet Restaurant\n"
        "- The Orange Moon Restaurant"
    )
)

def get_restaurant_candidates(number_of_restaurants, city, state):
    """
    Generate restaurant candidates using GPT-4 based on user inputs (number of restaurants, city, state).
    :param number_of_restaurants: The number of restaurant options to generate.
    :param city: The city where the restaurants are located.
    :param state: The state where the restaurants are located.
    :return: A list of restaurant names generated by GPT-4.
    """
    prompt = restaurant_prompt_template.format(
        number_of_restaurants=number_of_restaurants,
        city=city,
        state=state
    )
    response = model.invoke(prompt)  
    content = response.content  
    return content.strip().split("\n")[:number_of_restaurants] 

def start_election(max_votes):
    """
    Start a new election by initializing vote counts and setting the election status to 'ongoing'.
    :param max_votes: The maximum number of votes allowed for this election.
    """
    election_state.votes = {candidate: 0 for candidate in election_state.candidates}  
    election_state.election_status = 'ongoing'
    election_state.MAX_VOTES = max_votes

@app.route("/", methods=["GET", "POST"])
def index():
    """
    Main route that handles vote submission and displays the voting interface.
    - GET: Renders the voting page with available candidates.
    - POST: Processes vote submission, checks vote validity, and updates the vote count.
    """
    if request.method == "POST":
        total_votes = sum(election_state.votes.values())
        if total_votes < election_state.MAX_VOTES and election_state.election_status == 'ongoing':
            candidate = request.form.get("candidate")
            if candidate in election_state.votes:
                election_state.votes[candidate] += 1
                flash("Thank you! Your vote has been successfully submitted.", "success")
            else:
                flash("Invalid candidate selected.", "danger")
        elif total_votes >= election_state.MAX_VOTES:
            flash("All votes have been cast. The election is now closed.", "info")
            election_state.election_status = 'ended'
        return redirect(url_for("index"))

    remaining_votes = election_state.MAX_VOTES - sum(election_state.votes.values()) if election_state.MAX_VOTES else None
    return render_template("index.html", candidates=election_state.candidates, election_status=election_state.election_status, remaining_votes=remaining_votes, restaurant_election_started=election_state.restaurant_election_started)

@app.route("/voice_vote", methods=["POST"])
def voice_vote():
    """
    Handles voice-based voting by matching the recognized candidate from the transcript with the candidates.
    """
    data = request.get_json()

    transcript = data.get("transcript")
    if not transcript:
        return jsonify({"message": "No transcript provided."}), 400

    # Lowercase the transcript for case-insensitive matching
    transcript = transcript.lower()

    # Use difflib to find the best match for the spoken transcript
    candidate = difflib.get_close_matches(transcript, [c.lower() for c in election_state.candidates], n=1, cutoff=0.7)

    if candidate:
        # Convert the candidate back to the original case from the candidates list
        candidate = candidate[0]
        candidate = next((c for c in election_state.candidates if c.lower() == candidate), candidate)

        total_votes = sum(election_state.votes.values())
        if total_votes < election_state.MAX_VOTES and election_state.election_status == 'ongoing':
            election_state.votes[candidate] += 1
            return jsonify({"message": f"Thank you! Your vote for {candidate} has been submitted."}), 200
        else:
            return jsonify({"message": "All votes have been cast. The election is now closed."}), 200
    else:
        return jsonify({"message": "Candidate not recognized. Please try again."}), 400
    
@app.route("/choose_category", methods=["GET"])
def choose_category():
    """
    Route for choosing the election category (restaurant or custom candidates).
    """
    category = request.args.get('category', 'restaurant')  # Default to 'restaurant'
    return render_template("choose_category.html", category=category)

@app.route("/start_restaurant_election", methods=["POST"])
def start_restaurant_election():
    """
    Starts an election using GPT-4-generated restaurant candidates.
    - Retrieves user inputs for the number of restaurants, city, and state.
    - Starts the election with the generated candidates.
    """
    if 'generate_restaurants' in request.form:
        city = request.form.get('city')
        state = request.form.get('state')
        number_of_restaurants = int(request.form.get('number_of_restaurants'))
        max_votes = int(request.form.get('max_votes'))
        election_state.candidates = get_restaurant_candidates(number_of_restaurants, city, state)
        start_election(max_votes)
        election_state.restaurant_election_started = True
        flash("Restaurants have been generated. The election has started.", "info")
    return redirect(url_for("index"))

@app.route("/start_custom_election", methods=["POST"])
def start_custom_election():
    """
    Starts a custom election with user-provided candidates.
    - Retrieves the number of candidates and their names from the form.
    """
    number_of_candidates = int(request.form.get('number_of_custom_candidates'))
    max_votes = int(request.form.get('max_votes_custom'))

    # Collect the custom candidates from the form
    election_state.candidates = [request.form.get(f"candidate_{i + 1}") for i in range(number_of_candidates)]

    # Ensure all candidates have valid names
    election_state.candidates = [candidate for candidate in election_state.candidates if candidate.strip()]

    if len(election_state.candidates) < number_of_candidates:
        flash("Please provide valid names for all candidates.", "danger")
        return redirect(url_for('choose_category'))

    start_election(max_votes)
    flash("Custom candidates have been added. The election has started.", "info")
    
    return redirect(url_for("index"))

@app.route("/results")
def results():
    """
    Displays the election results, showing the percentage of votes for each candidate.
    """
    total_votes = sum(election_state.votes.values())
    results_percentage = {
        candidate: (count / total_votes) * 100 if total_votes > 0 else 0 
        for candidate, count in election_state.votes.items()
    }

    return render_template("results.html", results=results_percentage)

@app.route("/process_audio", methods=["POST"])
def process_audio():
    try:
        print("Processing audio request...")

        audio_file = request.files.get('audio')

        if not audio_file:
            print("No audio file found in the request.")
            return jsonify({'error': 'No audio file provided'}), 400

        audio_data = BytesIO(audio_file.read())
        audio_data.name = "voice_vote.wav"

        transcription = client.audio.transcriptions.create(
            model="whisper-1",
            file=audio_data
        )

        print("Transcription response:", transcription)

        if hasattr(transcription, 'text'):
            print("Transcription result:", transcription.text)
            return jsonify({'transcript': transcription.text}), 200
        else:
            print("No text field in transcription response.")
            return jsonify({'error': 'No transcription text found.'}), 500

    except openai.APIConnectionError as e:
        print("API connection error:", e)
        return jsonify({'error': 'API connection error. Please try again later.'}), 500

    except openai.RateLimitError as e:
        print("Rate limit exceeded:", e)
        return jsonify({'error': 'Rate limit exceeded. Please try again later.'}), 429

    except openai.BadRequestError as e:
        print(f"Bad request: {e}")

if __name__ == "__main__":
    app.run(debug=True)
