from flask import Flask, render_template, request, redirect, url_for, flash, jsonify
from dotenv import load_dotenv
from langchain_openai import ChatOpenAI
from langchain.prompts import PromptTemplate
from flask_sqlalchemy import SQLAlchemy
import difflib
import openai
from io import BytesIO 
import os

app = Flask(__name__)
app.secret_key = 'your_secret_key'

# Load environment variables from a .env file for security and flexibility
load_dotenv()
api_key = os.getenv("OPENAI_API_KEY")
db_uri = os.getenv("DATABASE_URL")

# Ensure the API key is provided in the environment
if not api_key:
    raise ValueError("API key not found. Ensure OPENAI_API_KEY is set in your environment.")

# Initialize OpenAI client with API key
client = openai.OpenAI(api_key=api_key)

# Initialize the GPT-4 model via LangChain for generating restaurant candidates
model = ChatOpenAI(model="gpt-4", api_key=api_key)

# LangChain prompt template for generating restaurant candidates based on user input
restaurant_prompt_template = PromptTemplate(
    input_variables=["number_of_restaurants", "city", "state"],
    template=(
        "Generate {number_of_restaurants} interesting restaurant options in {city}, {state}."
        " List each restaurant name on a new line.\n\n"
        "Example output:\n"
        "- The Blue Moon Restaurant\n"
        "- The Red Sun Restaurant\n"
        "- The Green Earth Restaurant\n"
        "- The Yellow Star Restaurant\n"
        "- The Purple Planet Restaurant\n"
        "- The Orange Moon Restaurant"
    )
)

# In-memory storage for votes and election state
votes = {}  # Dictionary to store votes for each candidate
candidates = []  # List to store current candidates
election_status = 'not_started'  # Tracks election status ('not_started', 'ongoing', 'ended')
MAX_VOTES = None  # Maximum number of votes allowed per election
restaurant_election_started = False  # Tracks whether a restaurant election has started

def get_restaurant_candidates(number_of_restaurants, city, state):
    """
    Generate restaurant candidates using GPT-4 based on user inputs (number of restaurants, city, state).
    :param number_of_restaurants: The number of restaurant options to generate.
    :param city: The city where the restaurants are located.
    :param state: The state where the restaurants are located.
    :return: A list of restaurant names generated by GPT-4.
    """
    prompt = restaurant_prompt_template.format(
        number_of_restaurants=number_of_restaurants,
        city=city,
        state=state
    )
    response = model.invoke(prompt)  # Query GPT-4 with the formatted prompt
    content = response.content  # Retrieve the response content
    return content.strip().split("\n")[:number_of_restaurants]  # Return the top restaurant names

def start_election(max_votes):
    """
    Start a new election by initializing vote counts and setting the election status to 'ongoing'.
    :param max_votes: The maximum number of votes allowed for this election.
    """
    global votes, election_status, MAX_VOTES
    votes = {candidate: 0 for candidate in candidates}  # Initialize vote counts to 0 for each candidate
    election_status = 'ongoing'
    MAX_VOTES = max_votes  # Set the vote limit

@app.route("/", methods=["GET", "POST"])
def index():
    """
    Main route that handles vote submission and displays the voting interface.
    - GET: Renders the voting page with available candidates.
    - POST: Processes vote submission, checks vote validity, and updates the vote count.
    """
    global candidates, votes, election_status, MAX_VOTES

    if request.method == "POST":
        # Check if the election is ongoing and if the vote count is below the allowed limit
        total_votes = sum(votes.values())
        if total_votes < MAX_VOTES and election_status == 'ongoing':
            candidate = request.form.get("candidate")  # Get the selected candidate from the form
            if candidate in votes:
                votes[candidate] += 1  # Increment the vote count for the selected candidate
                flash("Thank you! Your vote has been successfully submitted.", "success")
            else:
                flash("Invalid candidate selected.", "danger")
        elif total_votes >= MAX_VOTES:
            # End the election if the maximum vote count has been reached
            flash("All votes have been cast. The election is now closed.", "info")
            election_status = 'ended'
        return redirect(url_for("index"))

    # Calculate remaining votes
    remaining_votes = MAX_VOTES - sum(votes.values()) if MAX_VOTES else None
    return render_template("index.html", candidates=candidates, election_status=election_status, remaining_votes=remaining_votes, restaurant_election_started=restaurant_election_started)

@app.route("/voice_vote", methods=["POST"])
def voice_vote():
    """
    Handles voice-based voting by matching the recognized candidate from the transcript with the candidates.
    """
    global votes, election_status, MAX_VOTES
    data = request.get_json()

    transcript = data.get("transcript")
    if not transcript:
        return jsonify({"message": "No transcript provided."}), 400

    # Lowercase the transcript for case-insensitive matching
    transcript = transcript.lower()

    # Use difflib to find the best match for the spoken transcript
    candidate = difflib.get_close_matches(transcript, [c.lower() for c in candidates], n=1, cutoff=0.7)

    if candidate:
        # Convert the candidate back to the original case from the candidates list
        candidate = candidate[0]
        candidate = next((c for c in candidates if c.lower() == candidate), candidate)

        total_votes = sum(votes.values())
        if total_votes < MAX_VOTES and election_status == 'ongoing':
            votes[candidate] += 1
            return jsonify({"message": f"Thank you! Your vote for {candidate} has been submitted."}), 200
        else:
            return jsonify({"message": "All votes have been cast. The election is now closed."}), 200
    else:
        return jsonify({"message": "Candidate not recognized. Please try again."}), 400
    
@app.route("/choose_category", methods=["GET"])
def choose_category():
    """
    Route for choosing the election category (restaurant or custom candidates).
    """
    category = request.args.get('category', 'restaurant')  # Default to 'restaurant'
    return render_template("choose_category.html", category=category)

@app.route("/start_restaurant_election", methods=["POST"])
def start_restaurant_election():
    """
    Starts an election using GPT-4-generated restaurant candidates.
    - Retrieves user inputs for the number of restaurants, city, and state.
    - Starts the election with the generated candidates.
    """
    global candidates, votes, election_status, MAX_VOTES, restaurant_election_started

    if 'generate_restaurants' in request.form:
        city = request.form.get('city')
        state = request.form.get('state')
        number_of_restaurants = int(request.form.get('number_of_restaurants'))
        max_votes = int(request.form.get('max_votes'))
        candidates = get_restaurant_candidates(number_of_restaurants, city, state)  # Generate restaurant candidates
        start_election(max_votes)  # Start the election
        restaurant_election_started = True
        flash("Restaurants have been generated. The election has started.", "info")
    return redirect(url_for("index"))

@app.route("/start_custom_election", methods=["POST"])
def start_custom_election():
    """
    Starts a custom election with user-provided candidates.
    - Retrieves the number of candidates and their names from the form.
    """
    global candidates, votes, election_status, MAX_VOTES

    number_of_candidates = int(request.form.get('number_of_custom_candidates'))
    max_votes = int(request.form.get('max_votes_custom'))

    # Collect the custom candidates from the form
    candidates = [request.form.get(f"candidate_{i + 1}") for i in range(number_of_candidates)]

    # Ensure all candidates have valid names
    candidates = [candidate for candidate in candidates if candidate.strip()]
    
    if len(candidates) < number_of_candidates:
        flash("Please provide valid names for all candidates.", "danger")
        return redirect(url_for('choose_category'))

    start_election(max_votes)
    flash("Custom candidates have been added. The election has started.", "info")
    
    return redirect(url_for("index"))

@app.route("/results")
def results():
    """
    Displays the election results, showing the percentage of votes for each candidate.
    """
    total_votes = sum(votes.values())
    results_percentage = {candidate: (count / total_votes) * 100 if total_votes > 0 else 0 for candidate, count in votes.items()}

    return render_template("results.html", results=results_percentage)

@app.route("/process_audio", methods=["POST"])
def process_audio():
    try:
        # Log the incoming request
        print("Processing audio request...")

        # Get the audio file from the request
        audio_file = request.files.get('audio')

        if not audio_file:
            print("No audio file found in the request.")
            return jsonify({'error': 'No audio file provided'}), 400

        # Read the audio file in-memory using BytesIO (without saving locally)
        audio_data = BytesIO(audio_file.read())
        audio_data.name = "voice_vote.wav"  # Provide a name for the in-memory file

        # Transcribe the audio using the new API method
        transcription = client.audio.transcriptions.create(
            model="whisper-1",
            file=audio_data
        )

        # Log the full transcription response to understand its structure
        print("Transcription response:", transcription)

        # Check if 'text' is part of the transcription response
        if hasattr(transcription, 'text'):
            # Log the transcription text result
            print("Transcription result:", transcription.text)
            # Return the transcription to the frontend
            return jsonify({'transcript': transcription.text}), 200
        else:
            print("No text field in transcription response.")
            return jsonify({'error': 'No transcription text found.'}), 500

    except openai.APIConnectionError as e:
        print("API connection error:", e)
        return jsonify({'error': 'API connection error. Please try again later.'}), 500

    except openai.RateLimitError as e:
        print("Rate limit exceeded:", e)
        return jsonify({'error': 'Rate limit exceeded. Please try again later.'}), 429

    except openai.BadRequestError as e:
        print(f"Bad request: {e}")

if __name__ == "__main__":
    app.run(debug=True)
